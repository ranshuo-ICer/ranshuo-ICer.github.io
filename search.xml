<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/10/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fas fa-external-link-alt"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>如何建立自己的博客</title>
    <url>/2023/04/18/hexo-blog/</url>
    <content><![CDATA[<p>看到别人酷炫的博客，自己也想整一个，如何操作呢？本篇文章将手把手教你建立自己的博客</p>
<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><blockquote>
<p>Hexo 是一个快速、简洁且高效的静态博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。我们只需要通过 Markdown 语法写好自己的博客内容，然后通过简单的命令就能够将生成的网页上传到 Github，然后大家都可以来访问你的网页了。既方便了自己，也给了自己一个展示自己成果的平台，是不是一举两得</p>
</blockquote>
<p>Hexo官方也提供了一个安装教程，具体可以参考<a class="link"   href="https://easyhexo.com/" >Easy Hexo 👨‍💻<i class="fas fa-external-link-alt"></i></a>和 <a class="link"   href="https://hexo.io/docs/" >Documentation | Hexo<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><ul>
<li>Windows：下载并安装 <a class="link"   href="https://git-scm.com/download/win" >git<i class="fas fa-external-link-alt"></i></a>.</li>
<li>Mac：使用 <a class="link"   href="http://mxcl.github.com/homebrew/" >Homebrew<i class="fas fa-external-link-alt"></i></a>, <a class="link"   href="http://www.macports.org/" >MacPorts<i class="fas fa-external-link-alt"></i></a> 或者下载 <a class="link"   href="http://sourceforge.net/projects/git-osx-installer/" >安装程序<i class="fas fa-external-link-alt"></i></a>。</li>
<li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li>
<li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li>
</ul>
<h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>Node.js 为大多数平台提供了官方的 <a class="link"   href="https://nodejs.org/zh-cn/download/" >安装程序<i class="fas fa-external-link-alt"></i></a>。对于中国大陆地区用户，可以前往 <a class="link"   href="https://npmmirror.com/mirrors/node/" >淘宝 Node.js 镜像<i class="fas fa-external-link-alt"></i></a> 下载。</p>
<p>其它的安装方法：</p>
<ul>
<li>Windows：通过 <a class="link"   href="https://github.com/jasongin/nvs/" >nvs<i class="fas fa-external-link-alt"></i></a>（推荐）或者 <a class="link"   href="https://github.com/nvm-sh/nvm" >nvm<i class="fas fa-external-link-alt"></i></a> 安装。</li>
<li>Mac：使用 <a class="link"   href="https://brew.sh/" >Homebrew<i class="fas fa-external-link-alt"></i></a> 或 <a class="link"   href="http://www.macports.org/" >MacPorts<i class="fas fa-external-link-alt"></i></a> 安装。</li>
<li>Linux（DEB&#x2F;RPM-based）：从 <a class="link"   href="https://github.com/nodesource/distributions" >NodeSource<i class="fas fa-external-link-alt"></i></a> 安装。</li>
<li>其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 <a class="link"   href="https://nodejs.org/zh-cn/download/package-manager/" >指导<i class="fas fa-external-link-alt"></i></a>。</li>
</ul>
<p>我的电脑是Windows，下面带着一起使用nvs的方法安装Node.js</p>
<p>点击<a class="link"   href="https://github.com/jasongin/nvs/releases" >Releases · jasongin&#x2F;nvs (github.com)<i class="fas fa-external-link-alt"></i></a>下载Windows安装包</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/image/hexo-blog/1681780963272.png"
                      alt="1681780963272"
                ></p>
<p>下载完成后打开进行安装，安装完成界面如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/image/hexo-blog/1681781106078.png"
                      alt="1681781106078"
                ></p>
<p>点击 <code>finish</code>。</p>
<p>打开终端，输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nvs add lts</span><br></pre></td></tr></table></figure>

<p>安装最新的LTS版本</p>
<p>使用 <code>nvs link</code> 将node.js永久加入环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nvs <span class="built_in">link</span> lts</span><br></pre></td></tr></table></figure>

<h2 id="安装Hexo-1"><a href="#安装Hexo-1" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>经过上述步骤安装完node.js后即可使用 <code>npm</code>安装hexo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>新建完成后，指定文件夹的目录如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── <span class="built_in">source</span></span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<p>使用 <code>hexo g</code> 生成网页，<code>hexo s</code> 开启一个本地的服务，即可在本地浏览</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/image/hexo-blog/1681781945669.png"
                      alt="1681781945669"
                ></p>
<p>在浏览器中输入 <code>http://localhost:4000/</code>查看网页</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/image/hexo-blog/1681782072352.png"
                      alt="1681782072352"
                ></p>
<p>界面可能会不一样，因为我的使用了其他主题。</p>
<p>以上只是个简单的示例，我们需要根据自己的需求修改 <code>_config.yml</code>文件，具体参数请参考hexo官方和easy hexo</p>
<p>我们将在下一节用到 <code>_config.yaml</code></p>
<h1 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h1><h2 id="建立托管仓库"><a href="#建立托管仓库" class="headerlink" title="建立托管仓库"></a>建立托管仓库</h2><p>部署的前提是要有个github账号，如果你没有的话自己去注册一个，如果不会注册的话就退出吧，你应该也用不到QAQ（bushi）</p>
<p>在GitHub新建一个仓库，仓库名就是 <code>你注册时的用户名.github.io</code>：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/image/hexo-blog/1681782364729.png"
                      alt="1681782364729"
                ></p>
<h2 id="设置SSH"><a href="#设置SSH" class="headerlink" title="设置SSH"></a>设置SSH</h2><p>生成 ssh 密钥文件，输入如下命令后直接三次回车即可，一般不需要设置密码；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成 ssh 密钥</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;github 注册邮箱&quot;</span></span><br></pre></td></tr></table></figure>

<p>我生成秘钥的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;12345qq.com&quot;</span></span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic2.zhimg.com/80/v2-9e2d268a169026242849e2ff5325fcad_720w.webp"
                     
                ></p>
<p>一般执行上述命令之后，会生成 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个文件，前者是我们私有的，而后者则是对外开放的。接着找到生成的 <code>.ssh</code> 的文件夹中的 id_rsa.pub 密钥，将内容复制；</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/image/hexo-blog/1681782620156.png"
                      alt="1681782620156"
                ></p>
<p>然后打开 <a class="link"   href="https://link.zhihu.com/?target=https://github.com/settings/keys" >GitHub-Settings-Keys<i class="fas fa-external-link-alt"></i></a> 页面，创建一个新的 SSH key，填写 <code>Title</code> 和 <code>Key</code>，<code>Title</code> 可以随意，而 <code>Key</code> 的内容则是我们刚才复制的 <code>id_rsa.pub</code> 中的内容，最后点击 <code>Add SSH key</code> 即可；</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic2.zhimg.com/80/v2-fa367eb2c2c4749be656c34d782d6619_720w.webp"
                     
                ></p>
<h2 id="配置-config-yaml"><a href="#配置-config-yaml" class="headerlink" title="配置 _config.yaml"></a>配置 <code>_config.yaml</code></h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span> <span class="comment"># 类型填git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">&lt;repository</span> <span class="string">url&gt;</span> <span class="comment"># 你的Github仓库地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span> <span class="comment"># 分支名称。默认填写 master 如果您使用的是 GitHub ，程序会尝试自动检测。</span></span><br><span class="line">  <span class="attr">message:</span> <span class="comment"># 提交信息可以自定义，不填的则默认为提交时间</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，上述填写Github仓库地址的时候可以使用ssh地址，如果前面的ssh设置正确的话，可以不用输入密码就提交到github</p>
</blockquote>
<h2 id="配置-Git"><a href="#配置-Git" class="headerlink" title="配置 Git"></a>配置 Git</h2><p>如果你只是安装好了 Git 但没有配置过你的 Git ，那么现在需要做的第一件事情就是设置你的 Git 用户名和邮箱。 在 Git Bash 中执行以下两条命令配置你的用户名和邮箱，这里建议用户名和邮箱与你的 GitHub 用户名和邮箱保持一致。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;Your_user_name&quot;</span></span><br><span class="line">$ git config --global user.email Your_email@example.com</span><br></pre></td></tr></table></figure>

<h2 id="安装部署插件-opens-new-window"><a href="#安装部署插件-opens-new-window" class="headerlink" title="安装部署插件(opens new window)"></a>安装<a class="link"   href="https://github.com/hexojs/hexo-deployer-git" >部署插件(opens new window)<i class="fas fa-external-link-alt"></i></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">$ npm install hexo-server --save</span><br></pre></td></tr></table></figure>

<h2 id="发布到-GitHub"><a href="#发布到-GitHub" class="headerlink" title="发布到 GitHub"></a>发布到 GitHub</h2><p>在本地的 Hexo 站点根目录下，执行如下命令即可部署到 GitHub Pages 上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo d -g</span><br></pre></td></tr></table></figure>

<h1 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h1><p><img  
                     lazyload
                     alt="image"
                     data-src="/image/hexo-blog/1681783293434.png"
                      alt="1681783293434"
                ></p>
<p>上面是bing给出的回答。我使用的keep主题，可以直接使用keep的模板，非常方便。具体请参考keep官方<a class="link"   href="https://keep-docs.xpoet.cn/tutorial/get-start/quick-starter.html" >Keep 主题快速启动模板 | Keep 主题使用指南 (xpoet.cn)<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="下载模板"><a href="#下载模板" class="headerlink" title="下载模板"></a>下载模板</h2><h3 id="使用-Git-克隆"><a href="#使用-Git-克隆" class="headerlink" title="使用 Git 克隆"></a>使用 Git 克隆</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-keep/hexo-theme-keep-starter</span><br></pre></td></tr></table></figure>

<h3 id="直接下载"><a href="#直接下载" class="headerlink" title="直接下载"></a>直接下载</h3><p><a class="link"   href="https://github.com/theme-keep/hexo-theme-keep-starter/archive/refs/heads/main.zip" >点击这里下载 &gt;&gt; Keep 主题快速启动模板<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>「 Keep 主题快速启动模板 」下载完成之后，需要安装项目依赖才能成功运行起来。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo-theme-keep-starter</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意</p>
<p>使用 Keep 主题必须确保你的 Node.js 版本 &gt;&#x3D; 14.0，当你的 Hexo 项目运行时报错或发出警告时，请注意升级你的 Node.js 版本。</p>
</blockquote>
<h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>项目依赖安装成功之后，使用如下命令即可运行项目，随即在浏览器上看到 Keep 主题的 Hexo 博客。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm run server</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://cdn.staticaly.com/gh/XPoet/image-hosting@master/keep-docs/keep-starter.45ebf5je2to0.webp"
                      alt="keep-starter"
                ></p>
<h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>至此，我们可以直接在此模板上自由配置 Keep 主题，最后编译生成静态文件 -&gt; 部署发布。</p>
<p><strong>注意：为确保你的主题配置项完全生效，请在 <code>source/_data/keep.yml</code> 路径下进行主题配置。</strong></p>
<blockquote>
<p>请勿随意移动 <code>keep.yml</code> 文件的路径，确保 <code>keep.yml</code> 在 <code>source/_data/</code> 路径下。<br>请勿随意更改 <code>keep.yml</code> 文件中的配置项字段名称，填写配置项之后，确保缩进是否正确。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译生成静态文件</span></span><br><span class="line">$ npm run build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署</span></span><br><span class="line">$ npm run deploy</span><br></pre></td></tr></table></figure>

<p>部署到github的过程和前面一样，也需要在这个文件夹下安装git部署插件，修改 <code>_config.yaml</code>设置仓库路径。</p>
<hr>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><blockquote>
<p><a class="link"   href="https://keep-docs.xpoet.cn/" >Keep 主题使用指南 | Hexo 主题 Keep 官方文档 (xpoet.cn)<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://zhuanlan.zhihu.com/p/370635512" >超详细 Hexo + Github Pages 博客搭建教程 - 知乎 (zhihu.com)<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://hexo.io/zh-cn/docs/" >文档 | Hexo<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://easyhexo.com/" >Easy Hexo 👨‍💻<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装NVIDIA驱动</title>
    <url>/2023/04/17/ubuntu/Ubuntu%2018.04%20%E5%AE%89%E8%A3%85%20NVIDIA%20%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<p>我们今天的目标是在 Ubuntu 18.04 上安装 NVIDIA 显卡驱动，请注意，你的显卡一定要是 NVIDIA 的显卡才能按照这篇文章的方法安装。我将给大家介绍三种安装方法，建议使用第一种方法安装。</p>
<p>先来说说带有 NVIDIA 独立显卡的电脑为什么要安装 NVIDIA 显卡驱动吧。下面是我从维基百科摘抄的显卡工作原理的介绍：</p>
<blockquote>
<p>显卡是插在主板上的扩展槽里的（现在一般是 PCI-E 插槽，此前还有 AGP、PCI、ISA 等插槽）。它主要负责把主机向显示器发出的显示信号转化为一般电器信号，使得显示器能明白个人计算机在让它做什么。显卡的主要芯片叫“显示芯片”（Video chipset，也叫 GPU 或 VPU，图形处理器或视觉处理器），是显卡的主要处理单元。显卡上也有和计算机存储器相似的存储器，称为“显示存储器”，简称显存。<br>早期的显卡只是单纯意义的显卡，只起到信号转换的作用；当前我们一般使用的显卡都带有 3D 画面运算和图形加速功能，所以也叫做“图形加速卡”或“3D 加速卡”。PC 上最早的显卡是 IBM 在 1981 年推出的 5150 个人计算机上所搭载的 MDA 和 CGA 两款 2D 加速卡。<br>显卡通常由总线接口、PCB 板、显示芯片、显存、RAMDAC、VGA BIOS、VGA 功能插针、D-sub 插座及其他外围组件构成，现在的显卡大多还具有 VGA、DVI 显示器接口或者 HDMI 接口及 S-Video 端子和 Display Port 接口。</p>
</blockquote>
<p>电脑硬件有 NVIDIA 的显卡，但是没有驱动，那它是不能工作的，所以为了让显卡能够工作，发挥它的作用，我们需要安装显卡驱动。好的，下面来看看三种不同的安装方法吧。</p>
<h2 id="1-使用-Ubuntu-软件仓库中的稳定版本安装"><a href="#1-使用-Ubuntu-软件仓库中的稳定版本安装" class="headerlink" title="1. 使用 Ubuntu 软件仓库中的稳定版本安装"></a><strong>1. 使用 Ubuntu 软件仓库中的稳定版本安装</strong></h2><p><em>2020.08.09 补充：</em></p>
<p>介于许多朋友看了这篇文章介绍的方法安装还是会遇到问题，我这里补充一种更好的安装方法，也建议使用这种方法安装，其实我在下面这篇文章中有介绍，请参考 2.2 小节。</p>
<p><a class="link"   href="https://zhuanlan.zhihu.com/p/63584709" >史上最良心的 Ubuntu desktop 美化优化指导(1)<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="1-1-查看显卡硬件型号"><a href="#1-1-查看显卡硬件型号" class="headerlink" title="1.1. 查看显卡硬件型号"></a><strong>1.1. 查看显卡硬件型号</strong></h2><p>在终端输入：<code>ubuntu-drivers devices</code>，可以看到如下界面：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic1.zhimg.com/v2-5d32bffc05c68bf8edbd27fd20e837b0_b.webp?consumer=ZHI_MENG"
                     
                ></p>
<p>从上图可以看出，我的显卡是：<code>GM107M [GeForce GTX 860M]</code>，推荐安装的版本号是：<code>nvidia-driver-390 - distro non-free recommended</code>。</p>
<h2 id="1-2-开始安装"><a href="#1-2-开始安装" class="headerlink" title="1.2. 开始安装"></a><strong>1.2. 开始安装</strong></h2><ul>
<li>如果同意安装推荐版本，那我们只需要终端输入：<code>sudo ubuntu-drivers autoinstall</code> 就可以自动安装了。</li>
<li>当然我们也可以使用 apt 命令安装自己想要安装的版本，比如我想安装 <code>340</code> 这个版本号的版本，终端输入：<code>sudo apt install nvidia-340</code> 就自动安装了。</li>
<li>安装过程中按照提示操作，除非你知道每个提示的真实含义，否则所有的提示都选择默认就可以了，安装完成后重启系统，NVIDIA 显卡就可以正常工作了。安装完成后你可以参照 <code>https://linuxconfig.org/benchmark-your-graphics-card-on-linux</code> 上的介绍测试你的显卡。</li>
</ul>
<h2 id="2-使用-PPA-第三方软件仓库安装最新版本"><a href="#2-使用-PPA-第三方软件仓库安装最新版本" class="headerlink" title="2. 使用 PPA 第三方软件仓库安装最新版本"></a><strong>2. 使用 PPA 第三方软件仓库安装最新版本</strong></h2><ul>
<li>添加 PPA 软件仓库：<code>sudo add-apt-repository ppa:graphics-drivers/ppa</code>，需要输入用户密码，按照提示还需要按下 Enter 键。</li>
<li>更新软件索引：<code>sudo apt update</code></li>
<li>接下来的步骤同方法一，只是这样我们就可以选择安装最新版本的驱动程序了。</li>
</ul>
<h2 id="3-从-NVIDIA-官网下载最新版驱动手动安装"><a href="#3-从-NVIDIA-官网下载最新版驱动手动安装" class="headerlink" title="3. 从 NVIDIA 官网下载最新版驱动手动安装"></a><strong>3. 从 NVIDIA 官网下载最新版驱动手动安装</strong></h2><ul>
<li>打开终端，输入：<code>lshw -numeric -C display</code>，确认自己电脑显卡的型号，如下图：</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic1.zhimg.com/v2-592fd9491dfa98dfc005c2dd9e966404_b.webp?consumer=ZHI_MENG"
                     
                ></p>
<p>从上图可以看到，我的电脑的显卡是 <code>product: GM107M [GeForce GTX 860M] [10DE:1392]</code>，然后我们到 NVIDIA 的官网下载相应型号的驱动，官网地址是：<code>https://www.nvidia.com/Download/index.aspx</code>，如下图，我选择 GTX 860 显卡的驱动下载。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic3.zhimg.com/v2-586ce06ccebb8ec8d2013f81e4d1232e_b.webp?consumer=ZHI_MENG"
                     
                ></p>
<p>注意每个选项，特别是操作系统那里，一定选择 Linux 64-bit</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://picx.zhimg.com/v2-b4f188c51182c73f1054c39cef5c05ae_720w.jpg?source=b555e01d"
                     
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic1.zhimg.com/v2-9f3d8b0bc503cc760c01c440c84fceba.png"
                     
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://picx.zhimg.com/v2-b4f188c51182c73f1054c39cef5c05ae_720w.jpg?source=b555e01d"
                     
                >英伟达 NVIDIA Quadro RTX8000 专业显卡</p>
<p>京东</p>
<p>¥37999.00</p>
<p>去购买</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic1.zhimg.com/v2-9f3d8b0bc503cc760c01c440c84fceba.png"
                     
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://picx.zhimg.com/v2-b4f188c51182c73f1054c39cef5c05ae_720w.jpg?source=b555e01d"
                     
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic1.zhimg.com/v2-9f3d8b0bc503cc760c01c440c84fceba.png"
                     
                ></p>
<p>选好后点击 SEARCH 按钮搜索相应的驱动，如下图：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic4.zhimg.com/v2-cad8de4d54178b21244a0e2c124a55ff_b.webp?consumer=ZHI_MENG"
                     
                ></p>
<p>看到了吧，官方最新版本号已经是 418.43 了。点击 DOWNLOAD 按钮下载吧。</p>
<p>接着需要先安装一些 NVIDIA 显卡依赖的软件，在终端依次执行如下命令：</p>
<ul>
<li><code>sudo dpkg --add-architecture i386</code></li>
<li><code>sudo apt update</code></li>
<li><code>sudo apt install build-essential libc6:i386</code></li>
</ul>
<p>Ubuntu 系统默认安装好是使用的一个开源的驱动：<code>nouveau</code>，我们要安装官方的驱动需要先禁用这个开源驱动，方法如下，依次执行：</p>
<ul>
<li><code>sudo bash -c &quot;echo blacklist nouveau &gt; /etc/modprobe.d/blacklist-nvidia-nouveau.conf&quot;</code></li>
<li><code>sudo bash -c &quot;echo options nouveau modeset=0 &gt;&gt; /etc/modprobe.d/blacklist-nvidia-nouveau.conf&quot;</code></li>
</ul>
<p>执行完上面两条指令后，我们使用如下命令看看是否成功禁用了开源驱动：<code>cat /etc/modprobe.d/blacklist-nvidia-nouveau.conf</code>。如果和下面一样，表示成功了。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ cat /etc/modprobe.d/blacklist-nvidia-nouveau.conf</span><br><span class="line">blacklist nouveau</span><br><span class="line">options nouveau modeset=0</span><br></pre></td></tr></table></figure>

<p>这个时候我们需要先重启一下系统，重启吧。</p>
<p>重启成功后打开终端，输入如下命令：<code>sudo telinit 3</code>。然后按快捷键：<code>CTRL+ALT+F1</code> 进入字符界面，输入用户名和密码，然后登录系统，进入我们保存下载 NVIDIA 驱动的目录，默认是：<code>Downloads/</code> 目录，<code>cd Downloads/</code>，然后执行：<code>bash NVIDIA-Linux-x86_64-418.43.bin</code>。注意：<code>NVIDIA-Linux-x86_64-418.43.bin</code> 要根据你下载的驱动文件的名字相应改动。</p>
<p>安装过程中都点同意即可，如果你遇到下面的提示，安装下面我的输入输入后回车继续安装：</p>
<blockquote>
<p>The distribution-provided pre-install script failed!<br>Are you sure you want to continue? -&gt; <strong>CONTINUE INSTALLATION</strong><br>Would you like to run the nvidia-xconfig utility? -&gt; <strong>YES</strong></p>
</blockquote>
<p>安装完成后重启系统就可以点击软件列表中的 NVIDIA 的配置软件配置显卡驱动了，如果你遇到如下报错，请依次在终端输入如下命令解决：</p>
<ul>
<li>报错：WARNING: Unable to find suitable destination to install 32-bit compatibility libraries</li>
<li>解决办法：<ul>
<li>sudo dpkg –add-architecture i386</li>
<li>sudo apt update</li>
<li>sudo apt install libc6:i386</li>
</ul>
</li>
</ul>
<p>好了，今天分享了如何安装 NVIDIA 显卡驱动，再次提醒，如果你的显卡不是 NVIDIA 显卡，千万不要这么干，也不要在虚拟机中这么干。有什么不懂的可以留言和我讨论。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch损失函数CrossEntropyLoss和NLLLoss</title>
    <url>/2023/06/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/CrossEntropyLoss,%20NLLLoss%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="什么是logits"><a href="#什么是logits" class="headerlink" title="什么是logits"></a>什么是logits</h2><p>作者：王峰</p>
<p>链接：<a class="link"   href="https://www.zhihu.com/question/60751553/answer/1986650670" >https://www.zhihu.com/question/60751553/answer/1986650670<i class="fas fa-external-link-alt"></i></a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>logit原本是一个函数，它是sigmoid函数（也叫标准logistic函数） $p (x) &#x3D; \frac{1}{1+e^{-x}}$ 的反函数：  $logit(p) &#x3D; \log\left(\frac{p}{1-p}\right)$ 。logit这个名字的来源即为<strong>log</strong>istic un<strong>it。</strong></p>
<p>但在深度学习中，logits就是最终的全连接层的输出，而非其本意。通常神经网络中都是先有logits，而后通过sigmoid函数或者softmax函数得到概率$P$的，所以大部分情况下都无需用到logit函数的表达式。</p>
<p>什么时候我们会真的需要用到logit函数呢？考虑这样一个问题：如果我们拿到了一个黑盒模型的概率输出，想要用这个模型生成一批数据来distill（知识蒸馏）我们自己的模型，但distill过程往往又需要调节温度项来重新计算概率（大概是这么个形式： $p(x) &#x3D; \frac{1}{1+e^{-x&#x2F;T}}$ ），此时我们就需要从概率值反推logits了，而反推的过程就如上边的公式所述： $logit(p) &#x3D; \log\left(\frac{p}{1-p}\right)$ 。所以对于logistic regression来说，logit恰好是输出概率经过logit函数的结果，因此即使我们并没有真正地用到logit函数，也不妨将其称作logit。</p>
<p>但是，目前大家用得更多的是多分类的softmax函数，而它的反函数其实并不是logit函数，而是log函数 $\log(p)$ ，这样再次经过softmax函数： $\hat{p}_i &#x3D;\frac{e^{\log p_i}}{\sum_j e^{\log p_j}} &#x3D; \frac{p_i}{\sum_j p_j} &#x3D; p_i$ ，就得到了原来的概率。这里需要注意的是：所有logits共同减去一个数字，其得到的softmax结果是不变的，所以得到的logits并不一定与原始logits一模一样，而是会相差一个常数。</p>
<p>由此可见，使用logit一词来表示网络最后一层的输出，实际上只适用于logistic regression。而对于现在更多使用的多分类器softmax来说，其反函数应该是log函数，而非logit，继续用logit一词实际上是不恰当的。我个人倾向于使用“分数”或者直接说是最后一个全连接层的输出，这样比较形象，也不至于让初学者摸不到头脑。</p>
<h2 id="Softmax和Log-softmax"><a href="#Softmax和Log-softmax" class="headerlink" title="Softmax和Log_softmax"></a>Softmax和Log_softmax</h2><p>Softmax是标准的归一化函数，可以简单的理解为将神经网络的输出$[-\infin, +\infin]$归一化到$[0,1]$，并且各项的和是1，就好像输出的是属于不同类别的概率$P$</p>
<p>$$<br>Softmax(z_i)&#x3D;\frac{e^{z_i}}{\sum_{j&#x3D;0}^{n}{e^{z_j}}}</p>
<p>$$</p>
<p>但是在计算的过程中，若是$z_j$极大，会出现上溢出，当$z_j$为负数时，又容易出现下溢出问题（被四舍五入为0）。</p>
<p>经过适当变换</p>
<p>$$<br>Softmax(z_i)&#x3D;\frac{e^{z_i}e^{-max(z)}}{\sum_{j&#x3D;0}^{n}{e^{z_j}}e^{-max(z)}}&#x3D;\frac{e^{z_i-max(z)}}{\sum_{j&#x3D;0}^{n}{e^{z_j-max(z)}}}</p>
<p>$$</p>
<p>这样，$e$的指数最大为0，不会发生上溢出。对结果取$log$</p>
<p>$$<br>Log(Softmax(z_i))&#x3D;Log(\frac{e^{z_i-max(z)}}{\sum_{j&#x3D;0}^{n}{e^{z_j-max(z)}}})\<br>&#x3D;z_i-max(z)-Log(\sum_{j&#x3D;0}^ne^{z_j-max(z)})<br>$$</p>
<h2 id="交叉熵损失函数CrossEntropyLoss"><a href="#交叉熵损失函数CrossEntropyLoss" class="headerlink" title="交叉熵损失函数CrossEntropyLoss"></a>交叉熵损失函数CrossEntropyLoss</h2><p>之前提到过<a href="https://ranshuo-icer.github.io/2023/06/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E4%BB%80%E4%B9%88%E6%98%AFCrossEntropy%EF%BC%8C%E4%BA%A4%E5%8F%89%E7%86%B5/">什么是交叉熵损失函数 | RSIC&#39;s Blog (ranshuo-icer.github.io)</a></p>
<p>其公式为</p>
<p>$$<br>H(P,Q)&#x3D;-\sum_{i}P_i\times log(Q_i)<br>$$</p>
<p>即使用实际的分布$P$去计算预测的分布$Q$的平均编码长度。</p>
<p>在深度学习的分类任务中，$Q$通常为全连接的输出经过$softmax$得到，因此从全连接的输出$x$与真实标签$y$的交叉熵为</p>
<p>$$<br>H(y,x)&#x3D;-\sum_iy_i\times log(softmax(x))<br>$$</p>
<p>上面提到，为了避免计算softmax时出现溢出问题，都是计算的$log(softmax)$，再计算指数$e^{log(softmax)}$。当使用交叉熵作为损失函数时，即可省略后者，结合起来就是Pytorch中的 <code>nn.CrossEntropyLoss</code>，详见pytorch官方手册<a class="link"   href="https://pytorch.org/docs/stable/generated/torch.nn.CrossEntropyLoss.html#torch.nn.CrossEntropyLoss" >CrossEntropyLoss — PyTorch 2.0 documentation<i class="fas fa-external-link-alt"></i></a></p>
<p>那NLLLoss是什么呢？</p>
<p><a class="link"   href="https://pytorch.org/docs/stable/generated/torch.nn.NLLLoss.html#torch.nn.NLLLoss" >NLLLoss — PyTorch 2.0 documentation<i class="fas fa-external-link-alt"></i></a></p>
<p>The negative log likelihood loss. It is useful to train a classification problem with C classes. The input given through a forward call is expected to contain log-probabilities of each class. <strong>Obtaining log-probabilities in a neural network is easily achieved by adding a LogSoftmax layer in the last layer of your network. You may use CrossEntropyLoss instead, if you prefer not to add an extra layer.</strong></p>
<p>即 <code>softmax + log + nllloss = crossentropyloss</code></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习,损失函数</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是交叉熵损失函数</title>
    <url>/2023/06/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E4%BB%80%E4%B9%88%E6%98%AFCrossEntropy%EF%BC%8C%E4%BA%A4%E5%8F%89%E7%86%B5/</url>
    <content><![CDATA[<h2 id="1-熵-Entropy"><a href="#1-熵-Entropy" class="headerlink" title="1. 熵(Entropy)"></a>1. 熵(Entropy)</h2><h3 id="1-1-混乱程度，不确定性，还是信息量"><a href="#1-1-混乱程度，不确定性，还是信息量" class="headerlink" title="1.1 混乱程度，不确定性，还是信息量?"></a>1.1 混乱程度，不确定性，还是信息量?</h3><p>不同的人对熵有不同的解释：混乱程度，不确定性，惊奇程度，不可预测性，信息量等等，面对如此多的解释，第一次接触时难免困惑。本文第一部分，让我们先一起搞明白 熵 究竟是什么？</p>
<p>信息论中熵的概念首次被香农提出，目的是寻找一种高效&#x2F;无损地编码信息的方法：以编码后数据的平均长度来衡量高效性，平均长度越小越高效；同时还需满足“无损”的条件，即编码后不能有原始信息的丢失。这样，香农提出了熵的定义：无损编码事件信息的最小平均编码长度。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic3.zhimg.com/80/v2-8de58ebed3434892762f5809c1320462_720w.webp"
                     
                ></p>
<h3 id="1-2-计算编码长度"><a href="#1-2-计算编码长度" class="headerlink" title="1.2 计算编码长度"></a>1.2 计算编码长度</h3><p>上文提到了熵的定义：无损编码事件信息的最小平均编码长度。编码长度容易理解，但何来的最小，又何来的平均呢？下面以一个例子来说明：假设我们采用二进制编码东京的天气信息，并传输至纽约，其中东京的天气状态有4种可能，对应的概率如下图，每个可能性需要1个编码，东京的天气共需要4个编码。让我们采用3种编码方式，并对比下编码长度。不难发现，方式3编码长度最小，且是平均意义上的最小。方式3胜出的原因在于：对高可能性事件(Fine,Cloudy)用短编码，对低可能性事件(Rainy,Snow)用长编码。表中的3种方式，像是尝试的过程，那么能否直接计算出服从某一概率分布的事件的最小平均编码长度呢？还句话说，能不能直接计算熵？</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic1.zhimg.com/80/v2-73be23174f9ab59fe8ea5b2aa3e38f00_720w.webp"
                     
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic3.zhimg.com/80/v2-ba66e6343e2bdbdae034bd3fd8afd692_720w.webp"
                     
                ></p>
<h3 id="1-3-直接计算熵"><a href="#1-3-直接计算熵" class="headerlink" title="1.3 直接计算熵"></a>1.3 直接计算熵</h3><p>假设一个信息事件有8种可能的状态，且各状态等可能性，即可能性都是12.5%&#x3D;1&#x2F;8。我们需要多少位来编码8个值呢？1位可以编码2个值(0或1)，2位可以编码2×2&#x3D;4个值(00,01,10,11)，则8个值需要3位，2×2×2&#x3D;8(000,001,010,011,100,101,110,111)。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic1.zhimg.com/80/v2-b47bb0529992cc8454ec785c5bcdab08_720w.webp"
                     
                ></p>
<p>我们不能减少任何1位，因为那样会造成歧义，同样我们也不要多于3位来编码8个可能的值。归纳来看，对于具有N种等可能性状态的信息，每种状态的可能性P &#x3D; 1&#x2F;N，编码该信息所需的最小编码长度为：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic1.zhimg.com/80/v2-71c91e7e48db807b7afd329706df402c_720w.webp"
                     
                ></p>
<p>那么计算平均最小长度，也就是熵的公式为：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic3.zhimg.com/80/v2-b2f170c1b1c3afb539c78831e19830e2_720w.webp"
                     
                ></p>
<p>其中P(i)是第i个信息状态的可能性。</p>
<p>回头看看上述编码东京天气的例子，熵 &#x3D; 1 * 50% + 2 * 25% + 3 * 12.5% + 3 * 12.5% &#x3D; 1.75</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic1.zhimg.com/80/v2-8295d1cb67c122dd3958bb74ecbcc890_720w.webp"
                     
                ></p>
<h3 id="1-4-熵的直观解释"><a href="#1-4-熵的直观解释" class="headerlink" title="1.4 熵的直观解释"></a>1.4 熵的直观解释</h3><p>那么熵的那些描述和解释(混乱程度，不确定性，惊奇程度，不可预测性，信息量等)代表了什么呢？</p>
<p>如果熵比较大(即平均编码长度较长)，意味着这一信息有较多的可能状态，相应的每个状态的可能性比较低；因此每当来了一个新的信息，我们很难对其作出准确预测，即有着比较大的混乱程度&#x2F;不确定性&#x2F;不可预测性。</p>
<p>并且当一个罕见的信息到达时，比一个常见的信息有着更多的信息量，因为它排除了别的很多的可能性，告诉了我们一个确切的信息。在天气的例子中，Rainy发生的概率为12.5%，当接收到该信息时，我们减少了87.5%的不确定性(Fine,Cloudy,Snow)；如果接收到Fine(50%)的消息，我们只减少了50%的不确定性。</p>
<h2 id="2-交叉熵-Cross-Entropy"><a href="#2-交叉熵-Cross-Entropy" class="headerlink" title="2. 交叉熵(Cross-Entropy)"></a>2. 交叉熵(Cross-Entropy)</h2><h3 id="2-1-交叉熵损失函数？二分类交叉熵？"><a href="#2-1-交叉熵损失函数？二分类交叉熵？" class="headerlink" title="2.1 交叉熵损失函数？二分类交叉熵？"></a>2.1 交叉熵损失函数？二分类交叉熵？</h3><p>熟悉机器学习的人都知道分类模型中会使用交叉熵作损失函数，也一定对吴恩达的机器学习视频中猫分类器使用的二分类交叉熵印象深刻，但交叉熵究竟是什么？本文的第二部分，让我们一起搞明白交叉熵。字面上看，交叉熵分两部分“交叉”和“熵”，首先回顾下熵的公式吧。</p>
<h3 id="2-2-熵的公式"><a href="#2-2-熵的公式" class="headerlink" title="2.2 熵的公式"></a>2.2 熵的公式</h3><p>上文中已知一个离散变量 i 的概率分布P(i)，熵的公式可以表示为：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic4.zhimg.com/80/v2-487ad84da2878427c85a9a1bebd68687_720w.webp"
                     
                ></p>
<p>同理，对于连续变量 x 的概率分布P(x)，熵的公式可以表示为：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic1.zhimg.com/80/v2-3e4a1b992ee1e958a01309f34eaf6984_720w.webp"
                     
                ></p>
<p>在熵的公式中，对于离散变量和连续变量，我们都是计算了 负的可能性的对数 的期望，代表了该事件理论上的平均最小编码长度，所以熵的公式也可表示如下，公式中的x~P代表我们使用概率分布P来计算期望，熵又可以简写为H：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic3.zhimg.com/80/v2-4f8eaaf395834c003b3b10e2cee7219a_720w.webp"
                     
                ></p>
<p>重要的事情再说一遍：“熵是服从某一特定概率分布事件的理论最小平均编码长度”，只要我们知道了任何事件的概率分布，我们就可以计算它的熵；那如果我们不知道事件的概率分布，又想计算熵，该怎么做呢？那我们来对熵做一个估计吧，熵的估计的过程自然而然的引出了交叉熵。</p>
<h3 id="2-3-熵的估计"><a href="#2-3-熵的估计" class="headerlink" title="2.3 熵的估计"></a>2.3 熵的估计</h3><p>假如我们现在需要预报东京天气，在真实天气发生之前，我们不可能知道天气的概率分布；但为了下文的讨论，我们需要假设：对东京天气做一段时间的观测后，可以得到真实的概率分布P。</p>
<p>在观测之前，我们只有预估的概率分布Q，使用估计得到的概率分布，可以计算估计的熵：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic4.zhimg.com/80/v2-09bed805ad32e4882016e04e6241488b_720w.webp"
                     
                ></p>
<p>如果Q是真实的概率分布，根据上述公式，我们已经得到了编码东京天气信息的最小平均长度；然而估计的概率分布为我们的公式引入了两部分的不确定性：</p>
<ul>
<li>计算期望的概率分布是Q，与真实的概率分布P不同。</li>
<li>计算最小编码长度的概率是 -logQ，与真实的最小编码长度 -logP 不同。</li>
</ul>
<p>因为估计的概率分布Q影响了上述两个部分(期望和编码长度)，所以得到的结果很可能错得离谱，也因此该结果和真实熵的对比无意义。和香农的目标一样，我们希望编码长度尽可能的短，所以我们需要对比我们的编码长度和理论上的最小编码长度(熵)。假设经过观测后，我们得到了真实概率分布P，在天气预报时，就可以使用P计算平均编码长度，实际编码长度基于Q计算，这个计算结果就是P和Q的交叉熵。这样，实际编码长度和理论最小编码长度就有了对比的意义。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic4.zhimg.com/80/v2-cbe2e56b9876eb4e6053f96addac78e3_720w.webp"
                     
                ></p>
<h3 id="2-4-交叉熵-gt-x3D-熵"><a href="#2-4-交叉熵-gt-x3D-熵" class="headerlink" title="2.4 交叉熵 &gt;&#x3D; 熵"></a>2.4 交叉熵 &gt;&#x3D; 熵</h3><p>交叉熵使用H(P,Q)表示，意味着使用P计算期望，使用Q计算编码长度；所以H(P,Q)并不一定等于H(Q,P)，除了在P&#x3D;Q的情况下，H(P,Q) &#x3D; H(Q,P) &#x3D; H(P)。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic2.zhimg.com/80/v2-42abf8e445a3e72f8d5f24befeeb57f9_720w.webp"
                     
                ></p>
<p>有一点很微妙但很重要：对于期望，我们使用真实概率分布P来计算；对于编码长度，我们使用假设的概率分布Q来计算，因为它是预估用于编码信息的。因为熵是理论上的平均最小编码长度，所以交叉熵只可能大于等于熵。换句话说，如果我们的估计是完美的，即Q&#x3D;P，那么有H(P,Q) &#x3D; H(P)，否则，H(P,Q) &gt; H(P)。</p>
<p>至此，交叉熵和熵的关系应该比较明确了，下面让我们看看为什么要使用交叉熵作分类损失函数。</p>
<h3 id="2-5-交叉熵作为损失函数"><a href="#2-5-交叉熵作为损失函数" class="headerlink" title="2.5 交叉熵作为损失函数"></a>2.5 交叉熵作为损失函数</h3><p>假设一个动物照片的数据集中有5种动物，且每张照片中只有一只动物，每张照片的标签都是one-hot编码。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic3.zhimg.com/80/v2-7a01e17d8c517e60667a7fdb41723c0e_720w.webp"
                     
                ></p>
<p>第一张照片是狗的概率为100%，是其他的动物的概率是0；第二张照片是狐狸的概率是100%，是其他动物的概率是0，其余照片同理；因此可以计算下，每张照片的熵都为0。换句话说，以one-hot编码作为标签的每张照片都有100%的确定度，不像别的描述概率的方式：狗的概率为90%，猫的概率为10%。</p>
<p>假设有两个机器学习模型对第一张照片分别作出了预测：Q1和Q2,而第一张照片的真实标签为[1,0,0,0,0]。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic4.zhimg.com/80/v2-501d2c23dd7901b3d2b3e35de3539793_720w.webp"
                     
                ></p>
<p>两个模型预测效果如何呢，可以分别计算下交叉熵：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic1.zhimg.com/80/v2-8fdce81cdbdcdff42a9bbd2da6962fac_720w.webp"
                     
                ></p>
<p>交叉熵对比了模型的预测结果和数据的真实标签，随着预测越来越准确，交叉熵的值越来越小，如果预测完全正确，交叉熵的值就为0。因此，训练分类模型时，可以使用交叉熵作为损失函数。</p>
<h3 id="2-6-二分类交叉熵"><a href="#2-6-二分类交叉熵" class="headerlink" title="2.6 二分类交叉熵"></a>2.6 二分类交叉熵</h3><p>在二分类模型中，标签只有是和否两种；这时，可以使用二分类交叉熵作为损失函数。假设数据集中只有猫和狗的照片，则交叉熵公式中只包含两种可能性：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic3.zhimg.com/80/v2-73eaca821f3e144d23d97d8f8abba0fa_720w.webp"
                     
                ></p>
<p>又因为：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic1.zhimg.com/80/v2-672520a5d962592c0c9be913aaa79f6c_720w.webp"
                     
                ></p>
<p>所以交叉熵可以表示为：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic3.zhimg.com/80/v2-eb0942fe8ab442af55d7fb01cc142efa_720w.webp"
                     
                ></p>
<p>使用如下定义：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic2.zhimg.com/80/v2-9cc65f2405b7a4ad9f41bf48ed4fd995_720w.webp"
                     
                ></p>
<p>二分类的交叉熵可以写作如下形式，看起来就熟悉多了。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic4.zhimg.com/80/v2-5c5a0e7466941e34c83c72f3e509df63_720w.webp"
                     
                ></p>
<blockquote>
<p>“一文搞懂”系列的初衷有两个：一是记录&#x2F;分享自己工作学习中的收获，二是奢望 帮助入门者对相关概念有更清晰的认识。“一文搞懂”难免夸大其词，欢迎对文中观点进行讨论&#x2F;指正&#x2F;点赞！</p>
</blockquote>
<hr>
<p>转载自：<a class="link"   href="https://zhuanlan.zhihu.com/p/149186719?utm_id=0" >一文搞懂熵(Entropy),交叉熵(Cross-Entropy) - 知乎 (zhihu.com)<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习,损失函数</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH免密登陆</title>
    <url>/2023/04/17/ssh/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86/</url>
    <content><![CDATA[<h1 id="SSH免密登陆"><a href="#SSH免密登陆" class="headerlink" title="SSH免密登陆"></a>SSH免密登陆</h1><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li>终端</li>
<li>脑子</li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="生成秘钥"><a href="#生成秘钥" class="headerlink" title="生成秘钥"></a>生成秘钥</h3><ul>
<li>打开终端，输入 <code>ssh-keygen</code>，生成公钥和私钥</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/image/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86/1680612882454.png"
                      alt="1680612882454"
                ></p>
<ul>
<li>生成的文件如下：</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/image/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86/1680612946153.png"
                      alt="1680612946153"
                ></p>
<p>其中的 <code>*.pub</code>文件是公钥。</p>
<h3 id="部署公钥"><a href="#部署公钥" class="headerlink" title="部署公钥"></a>部署公钥</h3><ul>
<li>将公钥上传到服务器的 <code>user/.ssh/</code>目录下：</li>
</ul>
<p>在服务器的 <code>.ssh</code>目录下新建文件 <code>authorized_keys</code></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/image/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86/1680613300625.png"
                      alt="1680613300625"
                ></p>
<p>写入公钥的内容</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/image/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86/1680613342598.png"
                      alt="1680613342598"
                ></p>
<p>保存。至此设置好了服务器端</p>
<h3 id="使用私钥"><a href="#使用私钥" class="headerlink" title="使用私钥"></a>使用私钥</h3><h4 id="VScode使用方法"><a href="#VScode使用方法" class="headerlink" title="VScode使用方法"></a>VScode使用方法</h4><p>依次点击</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/image/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86/1680613473684.png"
                      alt="1680613473684"
                ></p>
<p>编辑文件</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/image/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86/1680613555967.png"
                      alt="1680613555967"
                ></p>
<p>点击保存即可</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>ImageNet数据集的下载与使用</title>
    <url>/2023/04/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/imageNet%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8B%E8%BD%BD%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="ImageNet数据集的下载与使用"><a href="#ImageNet数据集的下载与使用" class="headerlink" title="ImageNet数据集的下载与使用"></a>ImageNet数据集的下载与使用</h1><h2 id="1-数据下载"><a href="#1-数据下载" class="headerlink" title="1. 数据下载"></a>1. 数据下载</h2><h3 id="1-1-方法一：官网下载"><a href="#1-1-方法一：官网下载" class="headerlink" title="1.1 方法一：官网下载"></a>1.1 方法一：官网下载</h3><p><a href="https://link.zhihu.com/?target=https://www.image-net.org/">ImageNet <strong>www.image-net.org/</strong></a></p>
<p>在官方网站注册账号，注册时最好使用教育邮箱(.edu )之后。按照流程申请，收到邮件之后可以就可以在 Download界面里下数据啦~<br>推荐下载12年的数据，因为比较经典。不如果你如果凑巧财力雄厚，也可以考虑最顶上那个ImageNet21k，它相比12年的数据大的离谱。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pica.zhimg.com/80/v2-b757f1bbb9600f7ae4bc1dd551cbbfdb_720w.webp?source=1940ef5c"
                     
                ></p>
<p>点进去之后，下载如下三个压缩包（图片分类任务用这三个足够了）</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://picx.zhimg.com/80/v2-4c58bc88b0d657922d6ee7d4c9498b19_720w.webp?source=1940ef5c"
                     
                ></p>
<h3 id="1-2-方法二"><a href="#1-2-方法二" class="headerlink" title="1.2 方法二"></a>1.2 方法二</h3><p>如果你觉得这么下不方便&#x2F;网速太慢容易断，可以在这个网址自行找12年的版本下载（别全下了呀）</p>
<p><a href="https://link.zhihu.com/?target=https://hyper.ai/datasets/4889">ImageNet 10 图像识别数据集 - 数据集下载 - 超神经<strong>hyper.ai&#x2F;datasets&#x2F;4889</strong></a></p>
<h2 id="2-数据解压"><a href="#2-数据解压" class="headerlink" title="2. 数据解压"></a>2. 数据解压</h2><p>下载完毕后把 Development kit 留着备用，我们会得到训练集与验证集的两个压缩包，分别是 <code>ILSVRC2012_img_train.tar</code> 和 <code>ILSVRC2012_img_val.tar</code>。</p>
<p>首先创建两个用于放训练集和测试集的文件夹，然后解压：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">mkdir train</span><br><span class="line">mkdir val</span><br><span class="line">tar xvf ILSVRC2012_img_train.tar -C ./train</span><br><span class="line">tar xvf ILSVRC2012_img_val.tar -C ./val</span><br></pre></td></tr></table></figure>

<p>对于train的压缩包，解压之后其实还是1000个tar压缩包（对应1000个类别），需要再次解压，解压脚本unzip.sh如下（PS：可能需要自己改一下目录 dir ）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dir</span>=./train </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> `<span class="built_in">ls</span> <span class="variable">$dir</span>/*tar` <span class="keyword">do</span>   </span><br><span class="line">  filename=`<span class="built_in">basename</span> <span class="variable">$x</span> .tar`   </span><br><span class="line">  <span class="built_in">mkdir</span> <span class="variable">$dir</span>/<span class="variable">$filename</span>   </span><br><span class="line">  tar -xvf <span class="variable">$x</span> -C <span class="variable">$dir</span>/<span class="variable">$filename</span> </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="built_in">rm</span> *.tar</span><br></pre></td></tr></table></figure>

<p>执行脚本之后，我们就获得了1000个文件夹和对应的图片数据啦~截至目前，我们已经把所有的 JPEG 图片搞了出来。</p>
<h2 id="3-数据标签"><a href="#3-数据标签" class="headerlink" title="3. 数据标签"></a>3. 数据标签</h2><p>对于训练集，不同类别的数据躺在不同的文件夹里，用起来很方便（同一文件夹的视为一类）。但是验证集没有对应的标签，需要额外处理。</p>
<p>验证集的标签在 Development kit （文件名为 <code>ILSVRC2012_devkit_t12.tar.gz</code>）中的 <code>ILSVRC2012_devkit_t12\data\ILSVRC2012_validation_ground_truth.txt</code> 中：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://picx.zhimg.com/80/v2-10219b98d7686a62a5f86d3d7322ac6b_720w.webp?source=1940ef5c"
                     
                ></p>
<p>但是新的问题又来了，那就是这个数字和文件夹的名字虽然是一一对应的，但还是需要额外的映射……好在映射关系储存在和txt文件同目录下的 <code>meta.mat</code> 文件中。我们希望验证集的文件结构长得和训练集一样，即 :</p>
<ul>
<li>&#x2F;val<ul>
<li>&#x2F;n01440764<ul>
<li>images</li>
</ul>
</li>
<li>&#x2F;n01443537</li>
<li>images</li>
</ul>
</li>
</ul>
<p>因此，我们首先解压 devkit 压缩包，把我们需要的东西取出来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzf ILSVRC2012_devkit_t12.tar.gz</span><br></pre></td></tr></table></figure>

<p>之后，在imagenet目录（devkit和val的<a class="link"   href="https://www.zhihu.com/search?q=%E6%A0%B9%E7%9B%AE%E5%BD%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1930557182%7D" >根目录<i class="fas fa-external-link-alt"></i></a>下）创建并运行如下 python 脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move_valimg</span>(<span class="params">val_dir=<span class="string">&#x27;./val&#x27;</span>, devkit_dir=<span class="string">&#x27;./ILSVRC2012_devkit_t12&#x27;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    move valimg to correspongding folders.</span></span><br><span class="line"><span class="string">    val_id(start from 1) -&gt; ILSVRC_ID(start from 1) -&gt; WIND</span></span><br><span class="line"><span class="string">    organize like:</span></span><br><span class="line"><span class="string">    /val</span></span><br><span class="line"><span class="string">       /n01440764</span></span><br><span class="line"><span class="string">           images</span></span><br><span class="line"><span class="string">       /n01443537</span></span><br><span class="line"><span class="string">           images</span></span><br><span class="line"><span class="string">        .....</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># load synset, val ground truth and val images list</span></span><br><span class="line">    synset = io.loadmat(os.path.join(devkit_dir, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;meta.mat&#x27;</span>))</span><br><span class="line">  </span><br><span class="line">    ground_truth = <span class="built_in">open</span>(os.path.join(devkit_dir, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;ILSVRC2012_validation_ground_truth.txt&#x27;</span>))</span><br><span class="line">    lines = ground_truth.readlines()</span><br><span class="line">    labels = [<span class="built_in">int</span>(line[:-<span class="number">1</span>]) <span class="keyword">for</span> line <span class="keyword">in</span> lines]</span><br><span class="line">  </span><br><span class="line">    root, _, filenames = <span class="built_in">next</span>(os.walk(val_dir))</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">        <span class="comment"># val image name -&gt; ILSVRC ID -&gt; WIND</span></span><br><span class="line">        val_id = <span class="built_in">int</span>(filename.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>].split(<span class="string">&#x27;_&#x27;</span>)[-<span class="number">1</span>])</span><br><span class="line">        ILSVRC_ID = labels[val_id-<span class="number">1</span>]</span><br><span class="line">        WIND = synset[<span class="string">&#x27;synsets&#x27;</span>][ILSVRC_ID-<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;val_id:%d, ILSVRC_ID:%d, WIND:%s&quot;</span> % (val_id, ILSVRC_ID, WIND))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># move val images</span></span><br><span class="line">        output_dir = os.path.join(root, WIND)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(output_dir):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            os.mkdir(output_dir)</span><br><span class="line">        shutil.move(os.path.join(root, filename), os.path.join(output_dir, filename))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    move_valimg()</span><br></pre></td></tr></table></figure>

<h2 id="4-用Pytorch加载"><a href="#4-用Pytorch加载" class="headerlink" title="4. 用Pytorch加载"></a>4. 用Pytorch加载</h2><p>使用 torchvision.datasets.ImageFolder() 就可以直接加载处理好的数据集啦！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision.datasets <span class="keyword">as</span> datasets</span><br><span class="line"></span><br><span class="line">root = <span class="string">&#x27;data/imagenet&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_imagenet</span>(<span class="params">root, train = <span class="literal">True</span>, transform = <span class="literal">None</span>, target_transform = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> train:</span><br><span class="line">        root = os.path.join(root, <span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        root = os.path.join(root, <span class="string">&#x27;val&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> datasets.ImageFolder(root = root,</span><br><span class="line">                               transform = transform,</span><br><span class="line">                               target_transform = target_transform)</span><br></pre></td></tr></table></figure>

<p>作者：薰风初入弦<br>链接：<a class="link"   href="https://www.zhihu.com/question/264345314/answer/1930557182" >https://www.zhihu.com/question/264345314/answer/1930557182<i class="fas fa-external-link-alt"></i></a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<hr>
<blockquote>
<p>[^1] <a class="link"   href="https://www.zhihu.com/question/264345314" >ImageNet使用方法？ - 知乎 (zhihu.com)<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SCP拷贝文件</title>
    <url>/2023/04/17/ssh/ssh%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="使用SCP拷贝文件"><a href="#使用SCP拷贝文件" class="headerlink" title="使用SCP拷贝文件"></a>使用SCP拷贝文件</h1><p>有时候需要在跨设备复制文件，只要可以使用ssh登陆的设备即可使用scp命令实现文件的复制，非常方便</p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp username@192.168.xx.xxx://home/username/src /dest</span><br></pre></td></tr></table></figure>

<p>对于文件夹，需要加入 <code>-r</code>参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r username@192.168.xx.xxx://home/username/srcDir /destDir</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>更多使用方法请参考：<a class="link"   href="https://m.runoob.com/linux/linux-comm-scp.html" >Linux scp命令 | 菜鸟教程 (runoob.com)<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
</search>
